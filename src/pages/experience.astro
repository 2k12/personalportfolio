---
// 1. Importamos tu array de experiencias
import { EXPERIENCE } from "../components/Experience.astro";
import SectionContainer from "../components/SectionContainer.astro";
import Layout from "../layouts/Layout.astro";
---

<Layout
  title="Portfolio Joan - Desarrollador Web"
  description="Hola! Soy Joan Pastillo, un apasionado desarrollador full stack con +5 meses de experiencia creando soluciones digitales robustas y escalables."
>
  <main>
    <div class="hero-container">
      <canvas id="particle-canvas"></canvas>

      <div class="content-overlay" data-experience={JSON.stringify(EXPERIENCE)}>
        <SectionContainer id="experiencia" class="section">
          <!-- <h2
            class="text-4xl font-semibold mb-6 flex gap-x-3 items-center text-gradient justify-center"
          >
            Experiencia Profesional
          </h2> -->
          <div id="experience-preview"></div>
        </SectionContainer>
      </div>
    </div>
  </main>
</Layout>

<style>
  body {
    margin: 0;
    background-color: #000;
    overflow-x: hidden;
  }

  .hero-container {
    position: relative;
    width: 100%;
    height: 100vh;
    overflow: hidden;
  }

  #particle-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    /* Aseguramos que el canvas no capture clics */
    pointer-events: none;
  }

  .content-overlay {
    position: relative;
    z-index: 2;
    color: white;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    height: 100%;
    padding: 2rem;
  }

  .text-gradient {
    background: linear-gradient(to right, #7e3af2, #fc6610);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  #experience-preview {
    display: none;
    position: absolute; /* JS controlar√° top/left en desktop */
    /* transform: translate(-50%, -100%); <-- ELIMINADO, causaba conflicto */
    min-width: 260px;
    max-width: 320px;
    background: rgba(20, 20, 20, 0.75);
    border: 1px solid #7e3af2;
    border-radius: 12px;
    padding: 1rem 1.25rem;
    text-align: left;
    z-index: 100;
    backdrop-filter: blur(8px);
    color: white;
    opacity: 0;
    /* Transici√≥n solo para opacidad en desktop */
    transition: opacity 0.3s ease;
    pointer-events: none;
    box-shadow: 0 8px 20px rgba(126, 58, 242, 0.3);
  }

  /* Mostrar con efecto de aparici√≥n */
  #experience-preview.visible {
    display: block;
    opacity: 1;
    /* transform: translate(-50%, -110%) scale(1.02); */
    /* animation: floaty 2s ease-in-out infinite alternate; */
  }

  /*  */
  /* --- ‚ú® NUEVA SECCI√ìN RESPONSIVE ‚ú® --- */
  @media (max-width: 768px) {
    #experience-preview {
      /* Fijo en la parte inferior de la pantalla */
      position: fixed;

      /* Anulamos cualquier 'style' de JS */
      left: 50% !important;
      top: auto !important;
      bottom: 1rem; /* Margen inferior */

      /* Ancho responsive */
      width: 90vw;
      max-width: 500px;
      min-width: 0;

      /* Animaci√≥n de entrada/salida */
      opacity: 0;
      transform: translate(-50%, 20px); /* Empieza centrado y abajo */
      transition:
        opacity 0.3s ease,
        transform 0.3s ease;
    }

    #experience-preview.visible {
      opacity: 1;
      transform: translate(-50%, 0); /* Posici√≥n final */
    }
  }
</style>

<script>
  import * as THREE from "three";

  document.addEventListener("DOMContentLoaded", () => {
    // 5. Obtener los contenedores y los datos
    const container = document.getElementById("particle-canvas");
    const contentOverlay = document.querySelector(".content-overlay");
    const previewContainer = document.getElementById("experience-preview");

    if (!container || !contentOverlay || !previewContainer) {
      console.error("Faltan elementos esenciales del DOM.");
      return;
    }

    // 6. Parsear los datos de experiencia desde el atributo data-*
    let experienceData: any[] = [];
    try {
      const raw = (contentOverlay as HTMLElement).dataset.experience;
      if (!raw) {
        console.warn(
          "No experience data found in data-experience attribute. Using empty array."
        );
        experienceData = [];
      } else {
        experienceData = JSON.parse(raw);
      }
    } catch (e) {
      console.error("Error al parsear los datos de experiencia:", e);
      return;
    }

    // --- Configuraci√≥n de THREE.js ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    // Hacemos que el canvas del renderer S√ç capture eventos de mouse
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
      canvas: container, // Usamos el canvas existente
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    // Ya no usamos container.appendChild(renderer.domElement);

    camera.position.z = 6;

    // üåå Fondo de part√≠culas (sin cambios)
    const particlesCount = 2500;
    const positions = new Float32Array(particlesCount * 3);
    for (let i = 0; i < particlesCount * 3; i++) {
      positions[i] = (Math.random() - 0.5) * 15;
    }
    const particlesGeometry = new THREE.BufferGeometry();
    particlesGeometry.setAttribute(
      "position",
      new THREE.BufferAttribute(positions, 3)
    );
    const particlesMaterial = new THREE.PointsMaterial({
      size: 0.02,
      color: 0xffffff,
    });
    const particleSystem = new THREE.Points(
      particlesGeometry,
      particlesMaterial
    );
    scene.add(particleSystem);

    // ‚òÄÔ∏è Luz suave (sin cambios)
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(5, 5, 5);
    scene.add(light);

    // 7. Setup de Raycaster para clicks
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selectedPlanet: THREE.Mesh | null = null; // Rastrear el planeta seleccionado

    // üåç Crear planetas (basado en los datos)
    const colors = [0xfc6610, 0x7e3af2, 0x00ffff, 0x10fc61];
    const planets: THREE.Mesh[] = []; // Array para guardar los meshes de los planetas

    // 8. Usar experienceData.forEach en lugar de 'for (let i = 0; i < 4; i++)'
    experienceData.forEach((exp: any, i: number) => {
      const geometry = new THREE.SphereGeometry(0.25 + i * 0.05, 32, 32);
      const material = new THREE.MeshStandardMaterial({
        color: colors[i % colors.length],
        emissive: colors[i % colors.length],
        emissiveIntensity: 0.5,
        roughness: 0.4,
      });
      const planet = new THREE.Mesh(geometry, material);

      const radius = 1.5 + i;
      const angle = (i / experienceData.length) * Math.PI * 2;
      planet.position.x = Math.cos(angle) * radius;
      planet.position.y = Math.sin(angle) * (0.8 + i * 0.2);

      // 9. Guardar los datos y velocidad original en el planeta
      planet.userData = {
        id: i,
        data: exp,
        radius: radius,
        originalSpeed: 0.3 + i * 0.1,
      };

      planets.push(planet);
      scene.add(planet);
    });

    // üéûÔ∏è Animaci√≥n
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const elapsed = clock.getElapsedTime();

      particleSystem.rotation.y = elapsed * 0.05;

      // 10. Modificar la animaci√≥n para detener el planeta seleccionado
      planets.forEach((p) => {
        const data = p.userData;
        let currentSpeed = data.originalSpeed;

        if (selectedPlanet === p) {
          currentSpeed = 0; // Detener el planeta
          // Opcional: rotar lentamente sobre s√≠ mismo
          p.rotation.y += 0.005;
        }

        if (currentSpeed > 0) {
          const angle = elapsed * currentSpeed + data.id;
          p.position.x = Math.cos(angle) * data.radius;
          p.position.y = Math.sin(angle) * (data.radius * 0.5);
          p.rotation.y += 0.01;
        }
      });

      renderer.render(scene, camera);
    }
    animate();

    // üì± Responsivo
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });

    window.addEventListener("click", (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(planets);

      if (intersects.length > 0) {
        const clickedPlanet = intersects[0].object as THREE.Mesh;

        if (selectedPlanet === clickedPlanet) {
          // Si ya est√° seleccionado, cerramos el popup
          selectedPlanet = null;
          previewContainer.classList.remove("visible");
          return;
        }

        selectedPlanet = clickedPlanet;
        const data = clickedPlanet.userData.data;

        // üßæ Contenido de la tarjeta
        previewContainer.innerHTML = `
          <h3 class="text-gradient text-lg">${data.title}</h3>
          <h4 class="text-gray-400 text-md">${data.job} (${data.date})</h4>
          <p>${data.description}</p>
        `;

        // ‚ú® --- L√ìGICA RESPONSIVE --- ‚ú®
        const isMobile = window.innerWidth <= 768;

        if (isMobile) {
          // En m√≥vil, la CSS (media query) se encarga de todo.
          // Nos aseguramos de limpiar estilos 'inline' por si el usuario
          // redimensiona la ventana de desktop a m√≥vil.
          previewContainer.style.left = "";
          previewContainer.style.top = "";
        } else {
          // En desktop, usamos tu l√≥gica de posicionar junto al cursor

          // üìè Tama√±os estimados (los que ten√≠as)
          const cardWidth = 300;
          const cardHeight = 180;

          let x = event.clientX;
          let y = event.clientY;

          // üìç Determinar espacio (arriba/abajo)
          const spaceAbove = event.clientY;
          const spaceBelow = window.innerHeight - event.clientY;

          if (spaceBelow < cardHeight + 20 && spaceAbove > cardHeight + 20) {
            // Mostrar arriba
            y = event.clientY - cardHeight - 20;
          } else {
            // Mostrar abajo
            y = event.clientY + 20;
          }

          // üî∏ Ajustar para no salirse por los lados
          // (Centra la tarjeta en el cursor)
          let centeredX = x - cardWidth / 2;

          // Ajuste borde izquierdo
          centeredX = Math.max(20, centeredX);
          // Ajuste borde derecho
          centeredX = Math.min(centeredX, window.innerWidth - cardWidth - 20);

          x = centeredX;

          // üìç Aplicar posici√≥n segura
          previewContainer.style.left = `${x}px`;
          previewContainer.style.top = `${y}px`;
        }

        // Mostrar tarjeta (com√∫n para ambos)
        previewContainer.classList.add("visible");
      } else {
        selectedPlanet = null;
        previewContainer.classList.remove("visible");
      }
    });
  });
</script>
